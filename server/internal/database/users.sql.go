// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
        github_created_at,
        access_token,
        name,
        username,
        github_id,
        email,
        followers,
        following,
        panel_body,
        avatar_url,
        location
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    )
RETURNING github_id
`

type CreateUserParams struct {
	GithubCreatedAt time.Time
	AccessToken     string
	Name            string
	Username        string
	GithubID        int32
	Email           string
	Followers       int32
	Following       int32
	PanelBody       sql.NullString
	AvatarUrl       string
	Location        string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.GithubCreatedAt,
		arg.AccessToken,
		arg.Name,
		arg.Username,
		arg.GithubID,
		arg.Email,
		arg.Followers,
		arg.Following,
		arg.PanelBody,
		arg.AvatarUrl,
		arg.Location,
	)
	var github_id int32
	err := row.Scan(&github_id)
	return github_id, err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, created_at, updated_at, github_created_at, access_token, name, username, github_id, email, followers, following, panel_body, role, avatar_url, location
FROM users
LIMIT 20
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GithubCreatedAt,
			&i.AccessToken,
			&i.Name,
			&i.Username,
			&i.GithubID,
			&i.Email,
			&i.Followers,
			&i.Following,
			&i.PanelBody,
			&i.Role,
			&i.AvatarUrl,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByGithubID = `-- name: GetUserByGithubID :one
SELECT users.id, users.created_at, users.updated_at, users.github_created_at, users.access_token, users.name, users.username, users.github_id, users.email, users.followers, users.following, users.panel_body, users.role, users.avatar_url, users.location,
    SUM(repos.*) AS num_repos
FROM users
    JOIN repos ON users.github_id = repos.user_github_id
WHERE github_id = $1
`

type GetUserByGithubIDRow struct {
	ID              uuid.UUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	GithubCreatedAt time.Time
	AccessToken     string
	Name            string
	Username        string
	GithubID        int32
	Email           string
	Followers       int32
	Following       int32
	PanelBody       sql.NullString
	Role            UserRole
	AvatarUrl       string
	Location        string
	NumRepos        int64
}

func (q *Queries) GetUserByGithubID(ctx context.Context, githubID int32) (GetUserByGithubIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByGithubID, githubID)
	var i GetUserByGithubIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GithubCreatedAt,
		&i.AccessToken,
		&i.Name,
		&i.Username,
		&i.GithubID,
		&i.Email,
		&i.Followers,
		&i.Following,
		&i.PanelBody,
		&i.Role,
		&i.AvatarUrl,
		&i.Location,
		&i.NumRepos,
	)
	return i, err
}

const updateUserByGithubID = `-- name: UpdateUserByGithubID :one
UPDATE users
SET access_token = $1
WHERE github_id = $2
RETURNING id, created_at, updated_at, github_created_at, access_token, name, username, github_id, email, followers, following, panel_body, role, avatar_url, location
`

type UpdateUserByGithubIDParams struct {
	AccessToken string
	GithubID    int32
}

func (q *Queries) UpdateUserByGithubID(ctx context.Context, arg UpdateUserByGithubIDParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserByGithubID, arg.AccessToken, arg.GithubID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GithubCreatedAt,
		&i.AccessToken,
		&i.Name,
		&i.Username,
		&i.GithubID,
		&i.Email,
		&i.Followers,
		&i.Following,
		&i.PanelBody,
		&i.Role,
		&i.AvatarUrl,
		&i.Location,
	)
	return i, err
}

const updateUserInfo = `-- name: UpdateUserInfo :exec
UPDATE users
SET name = $1,
    username = $2,
    email = $3,
    panel_body = $4,
    updated_at = CURRENT_TIMESTAMP
`

type UpdateUserInfoParams struct {
	Name      string
	Username  string
	Email     string
	PanelBody sql.NullString
}

func (q *Queries) UpdateUserInfo(ctx context.Context, arg UpdateUserInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateUserInfo,
		arg.Name,
		arg.Username,
		arg.Email,
		arg.PanelBody,
	)
	return err
}

const updateUserToken = `-- name: UpdateUserToken :exec
UPDATE users
SET access_token = $1,
    updated_at = CURRENT_TIMESTAMP
`

func (q *Queries) UpdateUserToken(ctx context.Context, accessToken string) error {
	_, err := q.db.ExecContext(ctx, updateUserToken, accessToken)
	return err
}
