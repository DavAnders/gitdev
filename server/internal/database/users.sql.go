// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
        github_created_at,
        access_token,
        name,
        username,
        github_id,
        email,
        followers,
        following,
        bio,
        avatar_url,
        location
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    )
RETURNING github_id
`

type CreateUserParams struct {
	GithubCreatedAt time.Time
	AccessToken     string
	Name            string
	Username        string
	GithubID        int32
	Email           string
	Followers       int32
	Following       int32
	Bio             string
	AvatarUrl       string
	Location        string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.GithubCreatedAt,
		arg.AccessToken,
		arg.Name,
		arg.Username,
		arg.GithubID,
		arg.Email,
		arg.Followers,
		arg.Following,
		arg.Bio,
		arg.AvatarUrl,
		arg.Location,
	)
	var github_id int32
	err := row.Scan(&github_id)
	return github_id, err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, created_at, updated_at, github_created_at, access_token, name, username, github_id, email, followers, following, bio, title, avatar_url, location
FROM users
LIMIT 20
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GithubCreatedAt,
			&i.AccessToken,
			&i.Name,
			&i.Username,
			&i.GithubID,
			&i.Email,
			&i.Followers,
			&i.Following,
			&i.Bio,
			&i.Title,
			&i.AvatarUrl,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByGithubID = `-- name: GetUserByGithubID :one
SELECT users.id, users.created_at, users.updated_at, users.github_created_at, users.access_token, users.name, users.username, users.github_id, users.email, users.followers, users.following, users.bio, users.title, users.avatar_url, users.location,
    COUNT(repos.*) AS num_repos
FROM users
    LEFT JOIN repos ON users.github_id = repos.user_github_id
WHERE github_id = $1
GROUP BY users.id
`

type GetUserByGithubIDRow struct {
	ID              uuid.UUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	GithubCreatedAt time.Time
	AccessToken     string
	Name            string
	Username        string
	GithubID        int32
	Email           string
	Followers       int32
	Following       int32
	Bio             string
	Title           string
	AvatarUrl       string
	Location        string
	NumRepos        int64
}

func (q *Queries) GetUserByGithubID(ctx context.Context, githubID int32) (GetUserByGithubIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByGithubID, githubID)
	var i GetUserByGithubIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GithubCreatedAt,
		&i.AccessToken,
		&i.Name,
		&i.Username,
		&i.GithubID,
		&i.Email,
		&i.Followers,
		&i.Following,
		&i.Bio,
		&i.Title,
		&i.AvatarUrl,
		&i.Location,
		&i.NumRepos,
	)
	return i, err
}

const updateUserByGithubID = `-- name: UpdateUserByGithubID :one
UPDATE users
SET access_token = $1
WHERE github_id = $2
RETURNING id, created_at, updated_at, github_created_at, access_token, name, username, github_id, email, followers, following, bio, title, avatar_url, location
`

type UpdateUserByGithubIDParams struct {
	AccessToken string
	GithubID    int32
}

func (q *Queries) UpdateUserByGithubID(ctx context.Context, arg UpdateUserByGithubIDParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserByGithubID, arg.AccessToken, arg.GithubID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GithubCreatedAt,
		&i.AccessToken,
		&i.Name,
		&i.Username,
		&i.GithubID,
		&i.Email,
		&i.Followers,
		&i.Following,
		&i.Bio,
		&i.Title,
		&i.AvatarUrl,
		&i.Location,
	)
	return i, err
}

const updateUserInfo = `-- name: UpdateUserInfo :one
UPDATE users
SET name = $1,
    email = $2,
    bio = $3,
    title = $4,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, created_at, updated_at, github_created_at, access_token, name, username, github_id, email, followers, following, bio, title, avatar_url, location
`

type UpdateUserInfoParams struct {
	Name  string
	Email string
	Bio   string
	Title string
}

func (q *Queries) UpdateUserInfo(ctx context.Context, arg UpdateUserInfoParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserInfo,
		arg.Name,
		arg.Email,
		arg.Bio,
		arg.Title,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GithubCreatedAt,
		&i.AccessToken,
		&i.Name,
		&i.Username,
		&i.GithubID,
		&i.Email,
		&i.Followers,
		&i.Following,
		&i.Bio,
		&i.Title,
		&i.AvatarUrl,
		&i.Location,
	)
	return i, err
}

const updateUserToken = `-- name: UpdateUserToken :exec
UPDATE users
SET access_token = $1,
    updated_at = CURRENT_TIMESTAMP
`

func (q *Queries) UpdateUserToken(ctx context.Context, accessToken string) error {
	_, err := q.db.ExecContext(ctx, updateUserToken, accessToken)
	return err
}
